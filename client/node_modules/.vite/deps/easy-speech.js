import "./chunk-HUBM7RA2.js";

// node_modules/easy-speech/index.js
var EasySpeech = {};
var scope = globalThis;
var internal = {
  status: "created"
};
var patches = {};
EasySpeech.debug = (fn) => {
  debug = typeof fn === "function" ? fn : () => {
  };
};
var debug = () => {
};
EasySpeech.detect = () => detectFeatures();
var detectFeatures = () => {
  const features = {};
  [
    "speechSynthesis",
    "speechSynthesisUtterance",
    "speechSynthesisVoice",
    "speechSynthesisEvent",
    "speechSynthesisErrorEvent"
  ].forEach((feature) => {
    features[feature] = detect(feature);
  });
  features.onvoiceschanged = hasProperty(features.speechSynthesis, "onvoiceschanged");
  const hasUtterance = hasProperty(features.speechSynthesisUtterance, "prototype");
  utteranceEvents.forEach((event) => {
    const name = `on${event}`;
    features[name] = hasUtterance && hasProperty(features.speechSynthesisUtterance.prototype, name);
  });
  patches.isAndroid = isAndroid();
  patches.isFirefox = isFirefox();
  patches.isSafari = isSafari();
  debug(`is android: ${!!patches.isAndroid}`);
  debug(`is firefox: ${!!patches.isFirefox}`);
  debug(`is safari: ${!!patches.isSafari}`);
  return features;
};
var hasProperty = (target = {}, prop) => Object.hasOwnProperty.call(target, prop) || prop in target || !!target[prop];
var isAndroid = () => {
  const ua = (scope.navigator || {}).userAgent || "";
  return /android/i.test(ua);
};
var isFirefox = () => typeof scope.InstallTrigger !== "undefined";
var isSafari = () => typeof scope.GestureEvent !== "undefined";
var prefixes = ["webKit", "moz", "ms", "o"];
var capital = (s) => `${s.charAt(0).toUpperCase()}${s.slice(1)}`;
var detect = (baseName) => {
  const capitalBaseName = capital(baseName);
  const baseNameWithPrefixes = prefixes.map((p) => `${p}${capitalBaseName}`);
  const found = [baseName, capitalBaseName].concat(baseNameWithPrefixes).find(inGlobalScope);
  return scope[found];
};
var inGlobalScope = (name) => scope[name];
EasySpeech.status = () => ({ ...internal });
var status = (s) => {
  debug(s);
  internal.status = s;
};
EasySpeech.init = function({ maxTimeout = 5e3, interval = 250 } = {}) {
  return new Promise((resolve, reject) => {
    if (internal.initialized) {
      return resolve(false);
    }
    EasySpeech.reset();
    status("init: start");
    let timer;
    let voicesChangedListener;
    let completeCalled = false;
    const fail = (errorMessage) => {
      status(`init: failed (${errorMessage})`);
      clearInterval(timer);
      internal.initialized = false;
      return reject(new Error(`EasySpeech: ${errorMessage}`));
    };
    const complete = () => {
      if (completeCalled) {
        return;
      }
      status("init: complete");
      completeCalled = true;
      internal.initialized = true;
      clearInterval(timer);
      speechSynthesis.onvoiceschanged = null;
      if (voicesChangedListener) {
        speechSynthesis.removeEventListener("voiceschanged", voicesChangedListener);
      }
      return resolve(true);
    };
    const features = detectFeatures();
    const hasAllFeatures = !!features.speechSynthesis && !!features.speechSynthesisUtterance;
    if (!hasAllFeatures) {
      return fail("browser misses features");
    }
    Object.keys(features).forEach((feature) => {
      internal[feature] = features[feature];
    });
    const { speechSynthesis } = internal;
    const voicesLoaded = () => {
      const voices = speechSynthesis.getVoices() || [];
      if (voices.length > 0) {
        internal.voices = voices;
        status(`voices loaded: ${voices.length}`);
        internal.defaultVoice = voices.find((v) => v.default);
        if (!internal.defaultVoice) {
          const language = (scope.navigator || {}).language || "";
          const lang = language.split("-")[0];
          internal.defaultVoice = voices.find((v) => {
            return v.lang && (v.lang.indexOf(`${lang}-`) > -1 || v.lang.indexOf(`${lang}_`) > -1);
          });
        }
        if (!internal.defaultVoice) {
          internal.defaultVoice = voices[0];
        }
        return true;
      }
      return false;
    };
    status("init: voices");
    if (voicesLoaded()) {
      return complete();
    }
    const loadViaTimeout = () => {
      status("init: voices (timer)");
      let timeout = 0;
      timer = setInterval(() => {
        if (voicesLoaded()) {
          return complete();
        }
        if (timeout > maxTimeout) {
          return fail("browser has no voices (timeout)");
        }
        timeout += interval;
      }, interval);
    };
    if (features.onvoiceschanged) {
      status("init: voices (onvoiceschanged)");
      speechSynthesis.onvoiceschanged = () => {
        if (voicesLoaded()) {
          return complete();
        }
        return loadViaTimeout();
      };
      setTimeout(() => {
        if (voicesLoaded()) {
          return complete();
        }
        return fail("browser has no voices (timeout)");
      }, maxTimeout);
    } else {
      if (hasProperty(speechSynthesis, "addEventListener")) {
        status("init: voices (addEventListener)");
        voicesChangedListener = () => {
          if (voicesLoaded()) {
            return complete();
          }
        };
        speechSynthesis.addEventListener("voiceschanged", voicesChangedListener);
      }
      loadViaTimeout();
    }
  });
};
var ensureInit = ({ force } = {}) => {
  if (!force && !internal.initialized) {
    throw new Error("EasySpeech: not initialized. Run EasySpeech.init() first");
  }
};
EasySpeech.voices = () => {
  ensureInit();
  return internal.voices;
};
EasySpeech.on = (handlers) => {
  ensureInit();
  utteranceEvents.forEach((name) => {
    const handler = handlers[name];
    if (validate.handler(handler)) {
      internal.handlers[name] = handler;
    }
  });
  return { ...internal.handlers };
};
var utteranceEvents = [
  "boundary",
  "end",
  "error",
  "mark",
  "pause",
  "resume",
  "start"
];
var validate = {
  isNumber: (n) => typeof n === "number" && !Number.isNaN(n),
  pitch: (p) => validate.isNumber(p) && p >= 0 && p <= 2,
  volume: (v) => validate.isNumber(v) && v >= 0 && v <= 1,
  rate: (r) => validate.isNumber(r) && r >= 0.1 && r <= 10,
  text: (t) => typeof t === "string",
  handler: (h) => typeof h === "function",
  voice: (v) => v && v.lang && v.name && v.voiceURI
};
EasySpeech.defaults = (options) => {
  ensureInit();
  if (options) {
    internal.defaults = internal.defaults || {};
    ["voice", "pitch", "rate", "volume"].forEach((name) => {
      const value = options[name];
      const isValid = validate[name];
      if (isValid(value)) {
        internal.defaults[name] = value;
      }
    });
  }
  return { ...internal.defaults };
};
var getCurrentVoice = (voice) => {
  var _a, _b;
  return voice || ((_a = internal.defaults) == null ? void 0 : _a.voice) || internal.defaultVoice || ((_b = internal.voices) == null ? void 0 : _b[0]);
};
var createUtterance = (text) => {
  const UtteranceClass = internal.speechSynthesisUtterance;
  return new UtteranceClass(text);
};
EasySpeech.speak = ({ text, voice, pitch, rate, volume, force, ...handlers }) => {
  ensureInit({ force });
  if (!validate.text(text)) {
    throw new Error("EasySpeech: at least some valid text is required to speak");
  }
  const getValue = (options) => {
    var _a;
    const [name, value] = Object.entries(options)[0];
    if (validate[name](value)) {
      return value;
    }
    return (_a = internal.defaults) == null ? void 0 : _a[name];
  };
  return new Promise((resolve, reject) => {
    status("init speak");
    const utterance = createUtterance(text);
    const currentVoice = getCurrentVoice(voice);
    if (currentVoice) {
      utterance.voice = currentVoice;
      utterance.lang = currentVoice.lang;
      utterance.voiceURI = currentVoice.voiceURI;
    }
    utterance.text = text;
    utterance.pitch = getValue({ pitch });
    utterance.rate = getValue({ rate });
    utterance.volume = getValue({ volume });
    debugUtterance(utterance);
    utteranceEvents.forEach((name) => {
      var _a;
      const fn = handlers[name];
      if (validate.handler(fn)) {
        utterance.addEventListener(name, fn);
      }
      if ((_a = internal.handlers) == null ? void 0 : _a[name]) {
        utterance.addEventListener(name, internal.handlers[name]);
      }
    });
    utterance.addEventListener("start", () => {
      patches.paused = false;
      patches.speaking = true;
      if (!patches.isFirefox && !patches.isSafari && patches.isAndroid !== true) {
        resumeInfinity(utterance);
      }
    });
    utterance.addEventListener("end", (endEvent) => {
      status("speak complete");
      patches.paused = false;
      patches.speaking = false;
      clearTimeout(timeoutResumeInfinity);
      resolve(endEvent);
    });
    utterance.addEventListener("error", (errorEvent = {}) => {
      status(`speak failed: ${errorEvent.message}`);
      patches.paused = false;
      patches.speaking = false;
      clearTimeout(timeoutResumeInfinity);
      reject(errorEvent);
    });
    clearTimeout(timeoutResumeInfinity);
    internal.speechSynthesis.cancel();
    setTimeout(() => {
      internal.speechSynthesis.speak(utterance);
    }, 10);
  });
};
var debugUtterance = ({ voice, pitch, rate, volume }) => {
  debug(`utterance: voice=${voice == null ? void 0 : voice.name} volume=${volume} rate=${rate} pitch=${pitch}`);
};
var timeoutResumeInfinity;
function resumeInfinity(target) {
  if (!target && timeoutResumeInfinity) {
    debug("force-clear timeout");
    return scope.clearTimeout(timeoutResumeInfinity);
  }
  const { paused, speaking } = internal.speechSynthesis;
  const isSpeaking = speaking || patches.speaking;
  const isPaused = paused || patches.paused;
  debug(`resumeInfinity isSpeaking=${isSpeaking} isPaused=${isPaused}`);
  if (isSpeaking && !isPaused) {
    internal.speechSynthesis.pause();
    internal.speechSynthesis.resume();
  }
  timeoutResumeInfinity = scope.setTimeout(function() {
    resumeInfinity(target);
  }, 5e3);
}
EasySpeech.cancel = () => {
  ensureInit();
  status("cancelling");
  internal.speechSynthesis.cancel();
  patches.paused = false;
  patches.speaking = false;
};
EasySpeech.resume = () => {
  ensureInit();
  status("resuming");
  patches.paused = false;
  patches.speaking = true;
  internal.speechSynthesis.resume();
};
EasySpeech.pause = () => {
  ensureInit();
  status("pausing");
  if (patches.isAndroid) {
    debug("patch pause on Android with cancel");
    return internal.speechSynthesis.cancel();
  }
  internal.speechSynthesis.pause();
  patches.paused = true;
  patches.speaking = false;
};
EasySpeech.reset = () => {
  Object.assign(internal, {
    status: "reset",
    initialized: false,
    speechSynthesis: null,
    speechSynthesisUtterance: null,
    speechSynthesisVoice: null,
    speechSynthesisEvent: null,
    speechSynthesisErrorEvent: null,
    voices: null,
    defaultVoice: null,
    defaults: {
      pitch: 1,
      rate: 1,
      volume: 1,
      voice: null
    },
    handlers: {}
  });
};
var easy_speech_default = EasySpeech;
export {
  easy_speech_default as default
};
//# sourceMappingURL=easy-speech.js.map
